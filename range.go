// Copyright 2016 - 2019 The excelize Authors. All rights reserved. Use of
// this source code is governed by a BSD-style license that can be found in
// the LICENSE file.
//
// Package excelize providing a set of functions that allow you to write to
// and read from XLSX files. Support reads and writes XLSX file generated by
// Microsoft Excel™ 2007 and later. Support save file without losing original
// charts of XLSX. This library needs Go version 1.10 or later.

package excelize

import (
	"errors"
	_ "fmt"
	"reflect"
)

// write tow dimension slice or array
// evert element represents a row
func (f *File) SetRangeValue(sheet, axis string, values interface{}) error {
	rangeVal := reflect.ValueOf(values)
	rangeValKind := rangeVal.Kind()
	if rangeValKind != reflect.Slice && rangeValKind != reflect.Array {
		return errors.New("pointer to slice expected")
	}

	xlsx, err := f.workSheetReader(sheet)
	if err != nil {
		return err
	}

	startCol, startRow, err := CellNameToCoordinates(axis)
	if err != nil {
		return err
	}

	// a := [][]string{{"a","b","c"}, {"d", "r", "y", "t"}, {"c", "x"}, {"u"}}
	// a := []interface{}{[]string{"a","b","c"}, 2, 3, []string{"s","x"}}
	for i := 0; i < rangeVal.Len(); i++ {
		rowVal := rangeVal.Index(i)

		// a := []interface{}{[]string{"a","b","c"}, 2, 3, []string{"s","x"}}
		rowValKind := rowVal.Kind()
		if rowValKind == reflect.Interface {
			rowVal = reflect.ValueOf(rowVal.Interface())
			rowValKind = rowVal.Kind()
		}

		if rowValKind != reflect.Slice && rowValKind != reflect.Array {
			cell, err := CoordinatesToCellName(startCol, startRow+i)
			if err != nil {
				return err
			}

			if err := f.setCellValue(xlsx, cell, rowVal.Interface()); err != nil {
				return err
			}
			continue
		}

		for j := 0; j < rowVal.Len(); j++ {
			cell, err := CoordinatesToCellName(startCol+j, startRow+i)
			if err != nil {
				return err
			}

			if err := f.setCellValue(xlsx, cell, rowVal.Index(j).Interface()); err != nil {
				return err
			}
		}
	}
	return nil

}

func (f *File) GetRangeValue(sheet, hcell, vcell string) ([][]string, error) {
	// split row and col
	// var vrow, vcol, hrow, hcol int

	// if hcell == "" {
	// 	hcol, hrow = -1, -1
	// } else {
	// 	hcol, hrow, err := CellNameToCoordinates(hcell)
	// 	if err != nil {
	// 		return nil, err
	// 	}
	// }

	// if vcell == "" {
	// 	vcol, vrow = -1, -1
	// } else {
	// 	vcol, vrow, err := CellNameToCoordinates(vcell)
	// 	if err != nil {
	// 		return nil, err
	// 	}
	// }

	// // get rows
	// rows, err := f.Rows(sheet)
	// if err != nil {
	// 	return nil, err
	// }

	// // get length of row (max row)
	// maxRow = len(rows.rows)

	hcol, hrow, err := CellNameToCoordinates(hcell)
	if err != nil {
		return nil, err
	}

	vcol, vrow, err := CellNameToCoordinates(vcell)
	if err != nil {
		return nil, err
	}

	// Normalize the coordinate area, such correct C1:B3 to B1:C3.
	if vcol < hcol {
		vcol, hcol = hcol, vcol
	}

	if vrow < hrow {
		vrow, hrow = hrow, vrow
	}

	hcolIdx := hcol - 1
	hrowIdx := hrow - 1

	vcolIdx := vcol - 1
	vrowIdx := vrow - 1

	// 假设有：单元自动补全

	// 单元格拆分 by ":"
	// "a1:b4" [a1, b4] row,col,row,col
	// "a1:" [a1,""] row,col
	// "a1" [a1] row, col

	// GetRows 获取所有有效行
	// rows, err := f.Rows(sheet)
	// if err != nil {
	// 	return nil, err
	// }

	// if results := make([][]string, 0, 64)
	// for i:=
	// 从有效行有截取
	// 从指定位置开始取值 超过的部分都是空的 行是空行， 列跳过

	xlsx, err := f.workSheetReader(sheet)
	if err != nil {
		return nil, err
	}

	//Prevent hrow out of maxRow
	maxRow := len(xlsx.SheetData.Row)
	if hrow > maxRow {
		return nil, nil
	} else if vrow > maxRow {
		vrow = maxRow
		vrowIdx = vrow - 1
	}

	// Init result
	results := make([][]string, vrowIdx-hrowIdx+1)

	nullRowCount := 0
	currentVcolIdx := 0
	resultIdx := 0

	d := f.sharedStringsReader()
	for r := hrowIdx; r <= vrowIdx; r++ {
		//get row from sheet
		sheetRow := xlsx.SheetData.Row[r]
		maxCol := len(sheetRow.C)

		//Prevent hcol out of maxCol
		if hcol > maxCol {
			nullRowCount++
			results = append(results, make([]string, 0))
			continue
		} else if vrow > maxCol {
			currentVcolIdx = maxCol - 1
		} else {
			currentVcolIdx = vcolIdx
		}

		// make columns data
		columns := make([]string, currentVcolIdx-hcolIdx+1)
		colIdx := 0
		for k := hcolIdx; k <= currentVcolIdx; k++ {
			val, _ := sheetRow.C[k].getValueFrom(f, d)
			columns[colIdx] = val
			colIdx++
		}

		// save columns data
		results[resultIdx] = columns
		resultIdx++
	}

	// Return nil if all row is null
	if nullRowCount == maxRow {
		return nil, nil
	}

	return results, nil
}
