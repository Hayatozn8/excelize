// Copyright 2016 - 2019 The excelize Authors. All rights reserved. Use of
// this source code is governed by a BSD-style license that can be found in
// the LICENSE file.
//
// Package excelize providing a set of functions that allow you to write to
// and read from XLSX files. Support reads and writes XLSX file generated by
// Microsoft Excelâ„¢ 2007 and later. Support save file without losing original
// charts of XLSX. This library needs Go version 1.10 or later.

package excelize

import (
	"errors"
	"reflect"
)

// write tow dimension slice or array
// evert element represents a row
func (f *File) SetRangeValue(sheet, axis string, values interface{}) error {
	rangeVal := reflect.ValueOf(values)
	rangeValKind := rangeVal.Kind()
	if rangeValKind != reflect.Slice && rangeValKind != reflect.Array {
		return errors.New("pointer to slice expected")
	}

	xlsx, err := f.workSheetReader(sheet)
	if err != nil {
		return err
	}

	startCol, startRow, err := CellNameToCoordinates(axis)
	if err != nil {
		return err
	}

	// a := [][]string{{"a","b","c"}, {"d", "r", "y", "t"}, {"c", "x"}, {"u"}}
	// a := []interface{}{[]string{"a","b","c"}, 2, 3, []string{"s","x"}}
	for i := 0; i < rangeVal.Len(); i++ {
		rowVal := rangeVal.Index(i)

		// a := []interface{}{[]string{"a","b","c"}, 2, 3, []string{"s","x"}}
		rowValKind := rowVal.Kind()
		if rowValKind == reflect.Interface {
			rowVal = reflect.ValueOf(rowVal.Interface())
			rowValKind = rowVal.Kind()
		}

		if rowValKind != reflect.Slice && rowValKind != reflect.Array {
			cell, err := CoordinatesToCellName(startCol, startRow+i)
			if err != nil {
				return err
			}

			if err := f.setCellValue(xlsx, cell, rowVal.Interface()); err != nil {
				return err
			}
			continue
		}

		for j := 0; j < rowVal.Len(); j++ {
			cell, err := CoordinatesToCellName(startCol+j, startRow+i)
			if err != nil {
				return err
			}

			if err := f.setCellValue(xlsx, cell, rowVal.Index(j).Interface()); err != nil {
				return err
			}
		}
	}
	return nil

}

func (f *File) GetRangeValue(sheet, hcell, vcell string) ([][]string, error) {
	hcol, hrow, err := CellStrToCoordinates(hcell)
	if err != nil {
		return nil, err
	}

	vcol, vrow, err := CellStrToCoordinates(vcell)
	if err != nil {
		return nil, err
	}

	// "22" --> MAX_INT, 22
	// "A" --> 1, MAX_INT
	if hcol == -1 {
		hcol = int(^uint(0) >> 1)
	}

	if hrow == -1 {
		hrow = int(^uint(0) >> 1)
	}

	if vcol == -1 {
		vcol = int(^uint(0) >> 1)
	}

	if vrow == -1 {
		vrow = int(^uint(0) >> 1)
	}

	// Normalize the coordinate area, such correct C1:B3 to B1:C3.
	if vcol < hcol {
		vcol, hcol = hcol, vcol
	}

	if vrow < hrow {
		vrow, hrow = hrow, vrow
	}

	hcolIdx := hcol - 1
	hrowIdx := hrow - 1

	vcolIdx := vcol - 1
	vrowIdx := vrow - 1

	// Get sheet
	xlsx, err := f.workSheetReader(sheet)
	if err != nil {
		return nil, err
	}

	//Prevent hrow out of maxRow
	maxRow := len(xlsx.SheetData.Row)
	if hrow > maxRow {
		return nil, nil
	}
	if vrow > maxRow {
		vrow = maxRow
		vrowIdx = vrow - 1
	}

	// Init result
	results := make([][]string, vrowIdx-hrowIdx+1)

	nullRowCount := 0
	currentVcolIdx := 0
	resultIdx := -1

	d := f.sharedStringsReader()
	for r := hrowIdx; r <= vrowIdx; r++ {
		resultIdx++

		//get row from sheet
		sheetRow := xlsx.SheetData.Row[r]
		maxCol := len(sheetRow.C)

		//Prevent hcol out of maxCol
		if hcol > maxCol {
			nullRowCount++
			results[resultIdx] = make([]string, 0)
			continue
		}
		if vcol > maxCol {
			currentVcolIdx = maxCol - 1
		} else {
			currentVcolIdx = vcolIdx
		}

		// make columns data
		columns := make([]string, currentVcolIdx-hcolIdx+1)
		colIdx := 0
		for k := hcolIdx; k <= currentVcolIdx; k++ {
			val, _ := sheetRow.C[k].getValueFrom(f, d)
			columns[colIdx] = val
			colIdx++
		}

		// save columns data
		results[resultIdx] = columns
	}

	// Return nil if all row is null
	if nullRowCount == maxRow {
		return nil, nil
	}

	return results, nil
}
